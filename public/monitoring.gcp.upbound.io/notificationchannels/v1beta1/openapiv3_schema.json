{
  "$schema": "http://json-schema.org/schema#",
  "description": "NotificationChannel is the Schema for the NotificationChannels API. A NotificationChannel is a medium through which an alert is delivered when a policy violation is detected.",
  "type": "object",
  "required": [
    "spec"
  ],
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string",
      "enum": [
        "monitoring.gcp.upbound.io/v1beta1"
      ]
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string",
      "enum": [
        "NotificationChannel"
      ]
    },
    "metadata": {
      "type": "object",
      "properties": {
        "annotations": {
          "description": "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "labels": {
          "description": "Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "name": {
          "description": "Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names",
          "type": "string"
        }
      }
    },
    "spec": {
      "description": "NotificationChannelSpec defines the desired state of NotificationChannel",
      "type": "object",
      "required": [
        "forProvider"
      ],
      "properties": {
        "deletionPolicy": {
          "description": "DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either \"Delete\" or \"Orphan\" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223",
          "type": "string",
          "default": "Delete",
          "enum": [
            "Orphan",
            "Delete"
          ]
        },
        "forProvider": {
          "type": "object",
          "properties": {
            "description": {
              "description": "An optional human-readable description of this notification channel. This description may provide additional details, beyond the display name, for the channel. This may not exceed 1024 Unicode characters.",
              "type": "string"
            },
            "displayName": {
              "description": "An optional human-readable name for this notification channel. It is recommended that you specify a non-empty and unique name in order to make it easier to identify the channels in your project, though this is not enforced. The display name is limited to 512 Unicode characters.",
              "type": "string"
            },
            "enabled": {
              "description": "Whether notifications are forwarded to the described channel. This makes it possible to disable delivery of notifications to a particular channel without removing the channel from all alerting policies that reference the channel. This is a more convenient approach when the change is temporary and you want to receive notifications from the same set of alerting policies on the channel at some point in the future.",
              "type": "boolean"
            },
            "forceDelete": {
              "description": "If true, the notification channel will be deleted regardless of its use in alert policies (the policies will be updated to remove the channel). If false, channels that are still referenced by an existing alerting policy will fail to be deleted in a delete operation.",
              "type": "boolean"
            },
            "labels": {
              "description": "Configuration fields that define the channel and its behavior. The permissible and required labels are specified in the NotificationChannelDescriptor corresponding to the type field. They can also be configured via the sensitive_labels block, but cannot be configured in both places.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "project": {
              "description": "The ID of the project in which the resource belongs. If it is not provided, the provider project is used.",
              "type": "string"
            },
            "sensitiveLabels": {
              "description": "Different notification type behaviors are configured primarily using the the labels field on this resource. This block contains the labels which contain secrets or passwords so that they can be marked sensitive and hidden from plan output. The name of the field, eg: password, will be the key in the labels map in the api request. Credentials may not be specified in both locations and will cause an error. Changing from one location to a different credential configuration in the config will require an apply to update state. Structure is documented below.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "authTokenSecretRef": {
                    "description": "An authorization token for a notification channel. Channel types that support this field include: slack Note: This property is sensitive and will not be displayed in the plan.",
                    "type": "object",
                    "required": [
                      "key",
                      "name",
                      "namespace"
                    ],
                    "properties": {
                      "key": {
                        "description": "The key to select.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the secret.",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the secret.",
                        "type": "string"
                      }
                    }
                  },
                  "passwordSecretRef": {
                    "description": "An password for a notification channel. Channel types that support this field include: webhook_basicauth Note: This property is sensitive and will not be displayed in the plan.",
                    "type": "object",
                    "required": [
                      "key",
                      "name",
                      "namespace"
                    ],
                    "properties": {
                      "key": {
                        "description": "The key to select.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the secret.",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the secret.",
                        "type": "string"
                      }
                    }
                  },
                  "serviceKeySecretRef": {
                    "description": "An servicekey token for a notification channel. Channel types that support this field include: pagerduty Note: This property is sensitive and will not be displayed in the plan.",
                    "type": "object",
                    "required": [
                      "key",
                      "name",
                      "namespace"
                    ],
                    "properties": {
                      "key": {
                        "description": "The key to select.",
                        "type": "string"
                      },
                      "name": {
                        "description": "Name of the secret.",
                        "type": "string"
                      },
                      "namespace": {
                        "description": "Namespace of the secret.",
                        "type": "string"
                      }
                    }
                  }
                }
              }
            },
            "type": {
              "description": "The type of the notification channel. This field matches the value of the NotificationChannelDescriptor.type field. See https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.notificationChannelDescriptors/list to get the list of valid values such as \"email\", \"slack\", etc...",
              "type": "string"
            },
            "userLabels": {
              "description": "User-supplied key/value data that does not need to conform to the corresponding NotificationChannelDescriptor's schema, unlike the labels field. This field is intended to be used for organizing and identifying the NotificationChannel objects.The field can contain up to 64 entries. Each key and value is limited to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values can contain only lowercase letters, numerals, underscores, and dashes. Keys must begin with a letter.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            }
          }
        },
        "initProvider": {
          "description": "THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.",
          "type": "object",
          "properties": {
            "description": {
              "description": "An optional human-readable description of this notification channel. This description may provide additional details, beyond the display name, for the channel. This may not exceed 1024 Unicode characters.",
              "type": "string"
            },
            "displayName": {
              "description": "An optional human-readable name for this notification channel. It is recommended that you specify a non-empty and unique name in order to make it easier to identify the channels in your project, though this is not enforced. The display name is limited to 512 Unicode characters.",
              "type": "string"
            },
            "enabled": {
              "description": "Whether notifications are forwarded to the described channel. This makes it possible to disable delivery of notifications to a particular channel without removing the channel from all alerting policies that reference the channel. This is a more convenient approach when the change is temporary and you want to receive notifications from the same set of alerting policies on the channel at some point in the future.",
              "type": "boolean"
            },
            "forceDelete": {
              "description": "If true, the notification channel will be deleted regardless of its use in alert policies (the policies will be updated to remove the channel). If false, channels that are still referenced by an existing alerting policy will fail to be deleted in a delete operation.",
              "type": "boolean"
            },
            "labels": {
              "description": "Configuration fields that define the channel and its behavior. The permissible and required labels are specified in the NotificationChannelDescriptor corresponding to the type field. They can also be configured via the sensitive_labels block, but cannot be configured in both places.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            },
            "project": {
              "description": "The ID of the project in which the resource belongs. If it is not provided, the provider project is used.",
              "type": "string"
            },
            "sensitiveLabels": {
              "description": "Different notification type behaviors are configured primarily using the the labels field on this resource. This block contains the labels which contain secrets or passwords so that they can be marked sensitive and hidden from plan output. The name of the field, eg: password, will be the key in the labels map in the api request. Credentials may not be specified in both locations and will cause an error. Changing from one location to a different credential configuration in the config will require an apply to update state. Structure is documented below.",
              "type": "array",
              "items": {
                "type": "object"
              }
            },
            "type": {
              "description": "The type of the notification channel. This field matches the value of the NotificationChannelDescriptor.type field. See https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.notificationChannelDescriptors/list to get the list of valid values such as \"email\", \"slack\", etc...",
              "type": "string"
            },
            "userLabels": {
              "description": "User-supplied key/value data that does not need to conform to the corresponding NotificationChannelDescriptor's schema, unlike the labels field. This field is intended to be used for organizing and identifying the NotificationChannel objects.The field can contain up to 64 entries. Each key and value is limited to 63 Unicode characters or 128 bytes, whichever is smaller. Labels and values can contain only lowercase letters, numerals, underscores, and dashes. Keys must begin with a letter.",
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            }
          }
        },
        "managementPolicies": {
          "description": "THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md",
          "type": "array",
          "default": [
            "*"
          ],
          "items": {
            "description": "A ManagementAction represents an action that the Crossplane controllers can take on an external resource.",
            "type": "string",
            "enum": [
              "Observe",
              "Create",
              "Update",
              "Delete",
              "LateInitialize",
              "*"
            ]
          }
        },
        "providerConfigRef": {
          "description": "ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.",
          "type": "object",
          "default": {
            "name": "default"
          },
          "required": [
            "name"
          ],
          "properties": {
            "name": {
              "description": "Name of the referenced object.",
              "type": "string"
            },
            "policy": {
              "description": "Policies for referencing.",
              "type": "object",
              "properties": {
                "resolution": {
                  "description": "Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.",
                  "type": "string",
                  "default": "Required",
                  "enum": [
                    "Required",
                    "Optional"
                  ]
                },
                "resolve": {
                  "description": "Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.",
                  "type": "string",
                  "enum": [
                    "Always",
                    "IfNotPresent"
                  ]
                }
              }
            }
          }
        },
        "publishConnectionDetailsTo": {
          "description": "PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.",
          "type": "object",
          "required": [
            "name"
          ],
          "properties": {
            "configRef": {
              "description": "SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.",
              "type": "object",
              "default": {
                "name": "default"
              },
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "description": "Name of the referenced object.",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for referencing.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  }
                }
              }
            },
            "metadata": {
              "description": "Metadata is the metadata for connection secret.",
              "type": "object",
              "properties": {
                "annotations": {
                  "description": "Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as \"metadata.annotations\". - It is up to Secret Store implementation for others store types.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "labels": {
                  "description": "Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as \"metadata.labels\". - It is up to Secret Store implementation for others store types.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "type": {
                  "description": "Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.",
                  "type": "string"
                }
              }
            },
            "name": {
              "description": "Name is the name of the connection secret.",
              "type": "string"
            }
          }
        },
        "writeConnectionSecretToRef": {
          "description": "WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.",
          "type": "object",
          "required": [
            "name",
            "namespace"
          ],
          "properties": {
            "name": {
              "description": "Name of the secret.",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace of the secret.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-validations": [
        {
          "rule": "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.type) || (has(self.initProvider) \u0026\u0026 has(self.initProvider.type))",
          "message": "spec.forProvider.type is a required parameter"
        }
      ]
    }
  }
}