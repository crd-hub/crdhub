{
  "$schema": "http://json-schema.org/schema#",
  "description": "ServicePerimeter is the Schema for the ServicePerimeters API. ServicePerimeter describes a set of GCP resources which can freely import and export data amongst themselves, but not export outside of the ServicePerimeter.",
  "type": "object",
  "required": [
    "spec"
  ],
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string",
      "enum": [
        "accesscontextmanager.gcp.upbound.io/v1beta1"
      ]
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string",
      "enum": [
        "ServicePerimeter"
      ]
    },
    "metadata": {
      "type": "object",
      "properties": {
        "annotations": {
          "description": "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "labels": {
          "description": "Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "name": {
          "description": "Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names",
          "type": "string"
        }
      }
    },
    "spec": {
      "description": "ServicePerimeterSpec defines the desired state of ServicePerimeter",
      "type": "object",
      "required": [
        "forProvider"
      ],
      "properties": {
        "deletionPolicy": {
          "description": "DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either \"Delete\" or \"Orphan\" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223",
          "type": "string",
          "default": "Delete",
          "enum": [
            "Orphan",
            "Delete"
          ]
        },
        "forProvider": {
          "type": "object",
          "properties": {
            "description": {
              "description": "Description of the ServicePerimeter and its use. Does not affect behavior.",
              "type": "string"
            },
            "name": {
              "description": "Resource name for the ServicePerimeter. The short_name component must begin with a letter and only include alphanumeric and '_'. Format: accessPolicies/{policy_id}/servicePerimeters/{short_name}",
              "type": "string"
            },
            "parent": {
              "description": "The AccessPolicy this ServicePerimeter lives in. Format: accessPolicies/{policy_id}",
              "type": "string"
            },
            "perimeterType": {
              "description": "Specifies the type of the Perimeter. There are two types: regular and bridge. Regular Service Perimeter contains resources, access levels, and restricted services. Every resource can be in at most ONE regular Service Perimeter. In addition to being in a regular service perimeter, a resource can also be in zero or more perimeter bridges. A perimeter bridge only contains resources. Cross project operations are permitted if all effected resources share some perimeter (whether bridge or regular). Perimeter Bridge does not contain access levels or services: those are governed entirely by the regular perimeter that resource is in. Perimeter Bridges are typically useful when building more complex topologies with many independent perimeters that need to share some data with a common perimeter, but should not be able to share data among themselves. Default value is PERIMETER_TYPE_REGULAR. Possible values are: PERIMETER_TYPE_REGULAR, PERIMETER_TYPE_BRIDGE.",
              "type": "string"
            },
            "spec": {
              "description": "Proposed (or dry run) ServicePerimeter configuration. This configuration allows to specify and test ServicePerimeter configuration without enforcing actual access restrictions. Only allowed to be set when the useExplicitDryRunSpec flag is set. Structure is documented below.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "accessLevels": {
                    "description": "A list of AccessLevel resource names that allow resources within the ServicePerimeter to be accessed from the internet. AccessLevels listed must be in the same policy as this ServicePerimeter. Referencing a nonexistent AccessLevel is a syntax error. If no AccessLevel names are listed, resources within the perimeter can only be accessed via GCP calls with request origins within the perimeter. For Service Perimeter Bridge, must be empty. Format: accessPolicies/{policy_id}/accessLevels/{access_level_name}",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "accessLevelsRefs": {
                    "description": "References to AccessLevel to populate accessLevels.",
                    "type": "array",
                    "items": {
                      "description": "A Reference to a named object.",
                      "type": "object",
                      "required": [
                        "name"
                      ],
                      "properties": {
                        "name": {
                          "description": "Name of the referenced object.",
                          "type": "string"
                        },
                        "policy": {
                          "description": "Policies for referencing.",
                          "type": "object",
                          "properties": {
                            "resolution": {
                              "description": "Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.",
                              "type": "string",
                              "default": "Required",
                              "enum": [
                                "Required",
                                "Optional"
                              ]
                            },
                            "resolve": {
                              "description": "Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.",
                              "type": "string",
                              "enum": [
                                "Always",
                                "IfNotPresent"
                              ]
                            }
                          }
                        }
                      }
                    }
                  },
                  "accessLevelsSelector": {
                    "description": "Selector for a list of AccessLevel to populate accessLevels.",
                    "type": "object",
                    "properties": {
                      "matchControllerRef": {
                        "description": "MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.",
                        "type": "boolean"
                      },
                      "matchLabels": {
                        "description": "MatchLabels ensures an object with matching labels is selected.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      },
                      "policy": {
                        "description": "Policies for selection.",
                        "type": "object",
                        "properties": {
                          "resolution": {
                            "description": "Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.",
                            "type": "string",
                            "default": "Required",
                            "enum": [
                              "Required",
                              "Optional"
                            ]
                          },
                          "resolve": {
                            "description": "Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.",
                            "type": "string",
                            "enum": [
                              "Always",
                              "IfNotPresent"
                            ]
                          }
                        }
                      }
                    }
                  },
                  "egressPolicies": {
                    "description": "List of EgressPolicies to apply to the perimeter. A perimeter may have multiple EgressPolicies, each of which is evaluated separately. Access is granted if any EgressPolicy grants it. Must be empty for a perimeter bridge. Structure is documented below.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "egressFrom": {
                          "description": "Defines conditions on the source of a request causing this EgressPolicy to apply. Structure is documented below.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "identities": {
                                "description": "A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "identityType": {
                                "description": "Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of identities field will be allowed access. Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "egressTo": {
                          "description": "Defines the conditions on the ApiOperation and destination resources that cause this EgressPolicy to apply. Structure is documented below.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "externalResources": {
                                "description": "A list of external resources that are allowed to be accessed. A request matches if it contains an external resource in this list (Example: s3://bucket/path). Currently '*' is not allowed.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "operations": {
                                "description": "A list of ApiOperations the sources specified in corresponding IngressFrom are allowed to perform in this ServicePerimeter. Structure is documented below.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "methodSelectors": {
                                      "description": "API methods or permissions to allow. Method or permission must belong to the service specified by serviceName field. A single MethodSelector entry with * specified for the method field will allow all methods AND permissions for the service specified in serviceName. Structure is documented below.",
                                      "type": "array",
                                      "items": {
                                        "type": "object",
                                        "properties": {
                                          "method": {
                                            "description": "Value for method should be a valid method name for the corresponding serviceName in ApiOperation. If * used as value for method, then ALL methods and permissions are allowed.",
                                            "type": "string"
                                          },
                                          "permission": {
                                            "description": "Value for permission should be a valid Cloud IAM permission for the corresponding serviceName in ApiOperation.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    },
                                    "serviceName": {
                                      "description": "The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with serviceName field set to * will allow all methods AND permissions for all services.",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "resources": {
                                "description": "A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "ingressPolicies": {
                    "description": "List of IngressPolicies to apply to the perimeter. A perimeter may have multiple IngressPolicies, each of which is evaluated separately. Access is granted if any Ingress Policy grants it. Must be empty for a perimeter bridge. Structure is documented below.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "ingressFrom": {
                          "description": "Defines the conditions on the source of a request causing this IngressPolicy to apply. Structure is documented below.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "identities": {
                                "description": "A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "identityType": {
                                "description": "Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of identities field will be allowed access. Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.",
                                "type": "string"
                              },
                              "sources": {
                                "description": "Sources that this IngressPolicy authorizes access from. Structure is documented below.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "accessLevel": {
                                      "description": "An AccessLevel resource name that allow resources within the ServicePerimeters to be accessed from the internet. AccessLevels listed must be in the same policy as this ServicePerimeter. Referencing a nonexistent AccessLevel will cause an error. If no AccessLevel names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL. If * is specified, then all IngressSources will be allowed.",
                                      "type": "string"
                                    },
                                    "resource": {
                                      "description": "A Google Cloud resource that is allowed to ingress the perimeter. Requests from these resources will be allowed to access perimeter data. Currently only projects are allowed. Format projects/{project_number} The project may be in any Google Cloud organization, not just the organization that the perimeter is defined in. * is not allowed, the case of allowing all Google Cloud resources only is not supported.",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "ingressTo": {
                          "description": "Defines the conditions on the ApiOperation and request destination that cause this IngressPolicy to apply. Structure is documented below.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "operations": {
                                "description": "A list of ApiOperations the sources specified in corresponding IngressFrom are allowed to perform in this ServicePerimeter. Structure is documented below.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "methodSelectors": {
                                      "description": "API methods or permissions to allow. Method or permission must belong to the service specified by serviceName field. A single MethodSelector entry with * specified for the method field will allow all methods AND permissions for the service specified in serviceName. Structure is documented below.",
                                      "type": "array",
                                      "items": {
                                        "type": "object",
                                        "properties": {
                                          "method": {
                                            "description": "Value for method should be a valid method name for the corresponding serviceName in ApiOperation. If * used as value for method, then ALL methods and permissions are allowed.",
                                            "type": "string"
                                          },
                                          "permission": {
                                            "description": "Value for permission should be a valid Cloud IAM permission for the corresponding serviceName in ApiOperation.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    },
                                    "serviceName": {
                                      "description": "The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with serviceName field set to * will allow all methods AND permissions for all services.",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "resources": {
                                "description": "A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "resources": {
                    "description": "A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "restrictedServices": {
                    "description": "GCP services that are subject to the Service Perimeter restrictions. Must contain a list of services. For example, if storage.googleapis.com is specified, access to the storage buckets inside the perimeter must meet the perimeter's access restrictions.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "vpcAccessibleServices": {
                    "description": "Specifies how APIs are allowed to communicate within the Service Perimeter. Structure is documented below.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "allowedServices": {
                          "description": "The list of APIs usable within the Service Perimeter. Must be empty unless enableRestriction is True.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "enableRestriction": {
                          "description": "Whether to restrict API calls within the Service Perimeter to the list of APIs specified in 'allowedServices'.",
                          "type": "boolean"
                        }
                      }
                    }
                  }
                }
              }
            },
            "status": {
              "description": "ServicePerimeter configuration. Specifies sets of resources, restricted services and access levels that determine perimeter content and boundaries. Structure is documented below.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "accessLevels": {
                    "description": "A list of AccessLevel resource names that allow resources within the ServicePerimeter to be accessed from the internet. AccessLevels listed must be in the same policy as this ServicePerimeter. Referencing a nonexistent AccessLevel is a syntax error. If no AccessLevel names are listed, resources within the perimeter can only be accessed via GCP calls with request origins within the perimeter. For Service Perimeter Bridge, must be empty. Format: accessPolicies/{policy_id}/accessLevels/{access_level_name}",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "accessLevelsRefs": {
                    "description": "References to AccessLevel to populate accessLevels.",
                    "type": "array",
                    "items": {
                      "description": "A Reference to a named object.",
                      "type": "object",
                      "required": [
                        "name"
                      ],
                      "properties": {
                        "name": {
                          "description": "Name of the referenced object.",
                          "type": "string"
                        },
                        "policy": {
                          "description": "Policies for referencing.",
                          "type": "object",
                          "properties": {
                            "resolution": {
                              "description": "Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.",
                              "type": "string",
                              "default": "Required",
                              "enum": [
                                "Required",
                                "Optional"
                              ]
                            },
                            "resolve": {
                              "description": "Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.",
                              "type": "string",
                              "enum": [
                                "Always",
                                "IfNotPresent"
                              ]
                            }
                          }
                        }
                      }
                    }
                  },
                  "accessLevelsSelector": {
                    "description": "Selector for a list of AccessLevel to populate accessLevels.",
                    "type": "object",
                    "properties": {
                      "matchControllerRef": {
                        "description": "MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.",
                        "type": "boolean"
                      },
                      "matchLabels": {
                        "description": "MatchLabels ensures an object with matching labels is selected.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      },
                      "policy": {
                        "description": "Policies for selection.",
                        "type": "object",
                        "properties": {
                          "resolution": {
                            "description": "Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.",
                            "type": "string",
                            "default": "Required",
                            "enum": [
                              "Required",
                              "Optional"
                            ]
                          },
                          "resolve": {
                            "description": "Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.",
                            "type": "string",
                            "enum": [
                              "Always",
                              "IfNotPresent"
                            ]
                          }
                        }
                      }
                    }
                  },
                  "egressPolicies": {
                    "description": "List of EgressPolicies to apply to the perimeter. A perimeter may have multiple EgressPolicies, each of which is evaluated separately. Access is granted if any EgressPolicy grants it. Must be empty for a perimeter bridge. Structure is documented below.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "egressFrom": {
                          "description": "Defines conditions on the source of a request causing this EgressPolicy to apply. Structure is documented below.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "identities": {
                                "description": "A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "identityType": {
                                "description": "Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of identities field will be allowed access. Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "egressTo": {
                          "description": "Defines the conditions on the ApiOperation and destination resources that cause this EgressPolicy to apply. Structure is documented below.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "externalResources": {
                                "description": "A list of external resources that are allowed to be accessed. A request matches if it contains an external resource in this list (Example: s3://bucket/path). Currently '*' is not allowed.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "operations": {
                                "description": "A list of ApiOperations the sources specified in corresponding IngressFrom are allowed to perform in this ServicePerimeter. Structure is documented below.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "methodSelectors": {
                                      "description": "API methods or permissions to allow. Method or permission must belong to the service specified by serviceName field. A single MethodSelector entry with * specified for the method field will allow all methods AND permissions for the service specified in serviceName. Structure is documented below.",
                                      "type": "array",
                                      "items": {
                                        "type": "object",
                                        "properties": {
                                          "method": {
                                            "description": "Value for method should be a valid method name for the corresponding serviceName in ApiOperation. If * used as value for method, then ALL methods and permissions are allowed.",
                                            "type": "string"
                                          },
                                          "permission": {
                                            "description": "Value for permission should be a valid Cloud IAM permission for the corresponding serviceName in ApiOperation.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    },
                                    "serviceName": {
                                      "description": "The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with serviceName field set to * will allow all methods AND permissions for all services.",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "resources": {
                                "description": "A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "ingressPolicies": {
                    "description": "List of IngressPolicies to apply to the perimeter. A perimeter may have multiple IngressPolicies, each of which is evaluated separately. Access is granted if any Ingress Policy grants it. Must be empty for a perimeter bridge. Structure is documented below.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "ingressFrom": {
                          "description": "Defines the conditions on the source of a request causing this IngressPolicy to apply. Structure is documented below.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "identities": {
                                "description": "A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "identityType": {
                                "description": "Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of identities field will be allowed access. Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.",
                                "type": "string"
                              },
                              "sources": {
                                "description": "Sources that this IngressPolicy authorizes access from. Structure is documented below.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "accessLevel": {
                                      "description": "An AccessLevel resource name that allow resources within the ServicePerimeters to be accessed from the internet. AccessLevels listed must be in the same policy as this ServicePerimeter. Referencing a nonexistent AccessLevel will cause an error. If no AccessLevel names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL. If * is specified, then all IngressSources will be allowed.",
                                      "type": "string"
                                    },
                                    "accessLevelRef": {
                                      "description": "Reference to a AccessLevel in accesscontextmanager to populate accessLevel.",
                                      "type": "object",
                                      "required": [
                                        "name"
                                      ],
                                      "properties": {
                                        "name": {
                                          "description": "Name of the referenced object.",
                                          "type": "string"
                                        },
                                        "policy": {
                                          "description": "Policies for referencing.",
                                          "type": "object",
                                          "properties": {
                                            "resolution": {
                                              "description": "Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.",
                                              "type": "string",
                                              "default": "Required",
                                              "enum": [
                                                "Required",
                                                "Optional"
                                              ]
                                            },
                                            "resolve": {
                                              "description": "Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.",
                                              "type": "string",
                                              "enum": [
                                                "Always",
                                                "IfNotPresent"
                                              ]
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "accessLevelSelector": {
                                      "description": "Selector for a AccessLevel in accesscontextmanager to populate accessLevel.",
                                      "type": "object",
                                      "properties": {
                                        "matchControllerRef": {
                                          "description": "MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.",
                                          "type": "boolean"
                                        },
                                        "matchLabels": {
                                          "description": "MatchLabels ensures an object with matching labels is selected.",
                                          "type": "object",
                                          "additionalProperties": {
                                            "type": "string"
                                          }
                                        },
                                        "policy": {
                                          "description": "Policies for selection.",
                                          "type": "object",
                                          "properties": {
                                            "resolution": {
                                              "description": "Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.",
                                              "type": "string",
                                              "default": "Required",
                                              "enum": [
                                                "Required",
                                                "Optional"
                                              ]
                                            },
                                            "resolve": {
                                              "description": "Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.",
                                              "type": "string",
                                              "enum": [
                                                "Always",
                                                "IfNotPresent"
                                              ]
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "resource": {
                                      "description": "A Google Cloud resource that is allowed to ingress the perimeter. Requests from these resources will be allowed to access perimeter data. Currently only projects are allowed. Format projects/{project_number} The project may be in any Google Cloud organization, not just the organization that the perimeter is defined in. * is not allowed, the case of allowing all Google Cloud resources only is not supported.",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "ingressTo": {
                          "description": "Defines the conditions on the ApiOperation and request destination that cause this IngressPolicy to apply. Structure is documented below.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "operations": {
                                "description": "A list of ApiOperations the sources specified in corresponding IngressFrom are allowed to perform in this ServicePerimeter. Structure is documented below.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "methodSelectors": {
                                      "description": "API methods or permissions to allow. Method or permission must belong to the service specified by serviceName field. A single MethodSelector entry with * specified for the method field will allow all methods AND permissions for the service specified in serviceName. Structure is documented below.",
                                      "type": "array",
                                      "items": {
                                        "type": "object",
                                        "properties": {
                                          "method": {
                                            "description": "Value for method should be a valid method name for the corresponding serviceName in ApiOperation. If * used as value for method, then ALL methods and permissions are allowed.",
                                            "type": "string"
                                          },
                                          "permission": {
                                            "description": "Value for permission should be a valid Cloud IAM permission for the corresponding serviceName in ApiOperation.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    },
                                    "serviceName": {
                                      "description": "The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with serviceName field set to * will allow all methods AND permissions for all services.",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "resources": {
                                "description": "A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "resources": {
                    "description": "A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "restrictedServices": {
                    "description": "GCP services that are subject to the Service Perimeter restrictions. Must contain a list of services. For example, if storage.googleapis.com is specified, access to the storage buckets inside the perimeter must meet the perimeter's access restrictions.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "vpcAccessibleServices": {
                    "description": "Specifies how APIs are allowed to communicate within the Service Perimeter. Structure is documented below.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "allowedServices": {
                          "description": "The list of APIs usable within the Service Perimeter. Must be empty unless enableRestriction is True.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "enableRestriction": {
                          "description": "Whether to restrict API calls within the Service Perimeter to the list of APIs specified in 'allowedServices'.",
                          "type": "boolean"
                        }
                      }
                    }
                  }
                }
              }
            },
            "title": {
              "description": "Human readable title. Must be unique within the Policy.",
              "type": "string"
            },
            "useExplicitDryRunSpec": {
              "description": "Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly exists for all Service Perimeters, and that spec is identical to the status for those Service Perimeters. When this flag is set, it inhibits the generation of the implicit spec, thereby allowing the user to explicitly provide a configuration (\"spec\") to use in a dry-run version of the Service Perimeter. This allows the user to test changes to the enforced config (\"status\") without actually enforcing them. This testing is done through analyzing the differences between currently enforced and suggested restrictions. useExplicitDryRunSpec must bet set to True if any of the fields in the spec are set to non-default values.",
              "type": "boolean"
            }
          }
        },
        "initProvider": {
          "description": "THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.",
          "type": "object",
          "properties": {
            "description": {
              "description": "Description of the ServicePerimeter and its use. Does not affect behavior.",
              "type": "string"
            },
            "name": {
              "description": "Resource name for the ServicePerimeter. The short_name component must begin with a letter and only include alphanumeric and '_'. Format: accessPolicies/{policy_id}/servicePerimeters/{short_name}",
              "type": "string"
            },
            "parent": {
              "description": "The AccessPolicy this ServicePerimeter lives in. Format: accessPolicies/{policy_id}",
              "type": "string"
            },
            "perimeterType": {
              "description": "Specifies the type of the Perimeter. There are two types: regular and bridge. Regular Service Perimeter contains resources, access levels, and restricted services. Every resource can be in at most ONE regular Service Perimeter. In addition to being in a regular service perimeter, a resource can also be in zero or more perimeter bridges. A perimeter bridge only contains resources. Cross project operations are permitted if all effected resources share some perimeter (whether bridge or regular). Perimeter Bridge does not contain access levels or services: those are governed entirely by the regular perimeter that resource is in. Perimeter Bridges are typically useful when building more complex topologies with many independent perimeters that need to share some data with a common perimeter, but should not be able to share data among themselves. Default value is PERIMETER_TYPE_REGULAR. Possible values are: PERIMETER_TYPE_REGULAR, PERIMETER_TYPE_BRIDGE.",
              "type": "string"
            },
            "spec": {
              "description": "Proposed (or dry run) ServicePerimeter configuration. This configuration allows to specify and test ServicePerimeter configuration without enforcing actual access restrictions. Only allowed to be set when the useExplicitDryRunSpec flag is set. Structure is documented below.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "egressPolicies": {
                    "description": "List of EgressPolicies to apply to the perimeter. A perimeter may have multiple EgressPolicies, each of which is evaluated separately. Access is granted if any EgressPolicy grants it. Must be empty for a perimeter bridge. Structure is documented below.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "egressFrom": {
                          "description": "Defines conditions on the source of a request causing this EgressPolicy to apply. Structure is documented below.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "identities": {
                                "description": "A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "identityType": {
                                "description": "Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of identities field will be allowed access. Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "egressTo": {
                          "description": "Defines the conditions on the ApiOperation and destination resources that cause this EgressPolicy to apply. Structure is documented below.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "externalResources": {
                                "description": "A list of external resources that are allowed to be accessed. A request matches if it contains an external resource in this list (Example: s3://bucket/path). Currently '*' is not allowed.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "operations": {
                                "description": "A list of ApiOperations the sources specified in corresponding IngressFrom are allowed to perform in this ServicePerimeter. Structure is documented below.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "methodSelectors": {
                                      "description": "API methods or permissions to allow. Method or permission must belong to the service specified by serviceName field. A single MethodSelector entry with * specified for the method field will allow all methods AND permissions for the service specified in serviceName. Structure is documented below.",
                                      "type": "array",
                                      "items": {
                                        "type": "object",
                                        "properties": {
                                          "method": {
                                            "description": "Value for method should be a valid method name for the corresponding serviceName in ApiOperation. If * used as value for method, then ALL methods and permissions are allowed.",
                                            "type": "string"
                                          },
                                          "permission": {
                                            "description": "Value for permission should be a valid Cloud IAM permission for the corresponding serviceName in ApiOperation.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    },
                                    "serviceName": {
                                      "description": "The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with serviceName field set to * will allow all methods AND permissions for all services.",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "resources": {
                                "description": "A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "ingressPolicies": {
                    "description": "List of IngressPolicies to apply to the perimeter. A perimeter may have multiple IngressPolicies, each of which is evaluated separately. Access is granted if any Ingress Policy grants it. Must be empty for a perimeter bridge. Structure is documented below.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "ingressFrom": {
                          "description": "Defines the conditions on the source of a request causing this IngressPolicy to apply. Structure is documented below.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "identities": {
                                "description": "A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "identityType": {
                                "description": "Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of identities field will be allowed access. Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.",
                                "type": "string"
                              },
                              "sources": {
                                "description": "Sources that this IngressPolicy authorizes access from. Structure is documented below.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "accessLevel": {
                                      "description": "An AccessLevel resource name that allow resources within the ServicePerimeters to be accessed from the internet. AccessLevels listed must be in the same policy as this ServicePerimeter. Referencing a nonexistent AccessLevel will cause an error. If no AccessLevel names are listed, resources within the perimeter can only be accessed via Google Cloud calls with request origins within the perimeter. Example accessPolicies/MY_POLICY/accessLevels/MY_LEVEL. If * is specified, then all IngressSources will be allowed.",
                                      "type": "string"
                                    },
                                    "resource": {
                                      "description": "A Google Cloud resource that is allowed to ingress the perimeter. Requests from these resources will be allowed to access perimeter data. Currently only projects are allowed. Format projects/{project_number} The project may be in any Google Cloud organization, not just the organization that the perimeter is defined in. * is not allowed, the case of allowing all Google Cloud resources only is not supported.",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "ingressTo": {
                          "description": "Defines the conditions on the ApiOperation and request destination that cause this IngressPolicy to apply. Structure is documented below.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "operations": {
                                "description": "A list of ApiOperations the sources specified in corresponding IngressFrom are allowed to perform in this ServicePerimeter. Structure is documented below.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "methodSelectors": {
                                      "description": "API methods or permissions to allow. Method or permission must belong to the service specified by serviceName field. A single MethodSelector entry with * specified for the method field will allow all methods AND permissions for the service specified in serviceName. Structure is documented below.",
                                      "type": "array",
                                      "items": {
                                        "type": "object",
                                        "properties": {
                                          "method": {
                                            "description": "Value for method should be a valid method name for the corresponding serviceName in ApiOperation. If * used as value for method, then ALL methods and permissions are allowed.",
                                            "type": "string"
                                          },
                                          "permission": {
                                            "description": "Value for permission should be a valid Cloud IAM permission for the corresponding serviceName in ApiOperation.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    },
                                    "serviceName": {
                                      "description": "The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with serviceName field set to * will allow all methods AND permissions for all services.",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "resources": {
                                "description": "A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "resources": {
                    "description": "A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "restrictedServices": {
                    "description": "GCP services that are subject to the Service Perimeter restrictions. Must contain a list of services. For example, if storage.googleapis.com is specified, access to the storage buckets inside the perimeter must meet the perimeter's access restrictions.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "vpcAccessibleServices": {
                    "description": "Specifies how APIs are allowed to communicate within the Service Perimeter. Structure is documented below.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "allowedServices": {
                          "description": "The list of APIs usable within the Service Perimeter. Must be empty unless enableRestriction is True.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "enableRestriction": {
                          "description": "Whether to restrict API calls within the Service Perimeter to the list of APIs specified in 'allowedServices'.",
                          "type": "boolean"
                        }
                      }
                    }
                  }
                }
              }
            },
            "status": {
              "description": "ServicePerimeter configuration. Specifies sets of resources, restricted services and access levels that determine perimeter content and boundaries. Structure is documented below.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "egressPolicies": {
                    "description": "List of EgressPolicies to apply to the perimeter. A perimeter may have multiple EgressPolicies, each of which is evaluated separately. Access is granted if any EgressPolicy grants it. Must be empty for a perimeter bridge. Structure is documented below.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "egressFrom": {
                          "description": "Defines conditions on the source of a request causing this EgressPolicy to apply. Structure is documented below.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "identities": {
                                "description": "A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "identityType": {
                                "description": "Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of identities field will be allowed access. Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "egressTo": {
                          "description": "Defines the conditions on the ApiOperation and destination resources that cause this EgressPolicy to apply. Structure is documented below.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "externalResources": {
                                "description": "A list of external resources that are allowed to be accessed. A request matches if it contains an external resource in this list (Example: s3://bucket/path). Currently '*' is not allowed.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "operations": {
                                "description": "A list of ApiOperations the sources specified in corresponding IngressFrom are allowed to perform in this ServicePerimeter. Structure is documented below.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "methodSelectors": {
                                      "description": "API methods or permissions to allow. Method or permission must belong to the service specified by serviceName field. A single MethodSelector entry with * specified for the method field will allow all methods AND permissions for the service specified in serviceName. Structure is documented below.",
                                      "type": "array",
                                      "items": {
                                        "type": "object",
                                        "properties": {
                                          "method": {
                                            "description": "Value for method should be a valid method name for the corresponding serviceName in ApiOperation. If * used as value for method, then ALL methods and permissions are allowed.",
                                            "type": "string"
                                          },
                                          "permission": {
                                            "description": "Value for permission should be a valid Cloud IAM permission for the corresponding serviceName in ApiOperation.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    },
                                    "serviceName": {
                                      "description": "The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with serviceName field set to * will allow all methods AND permissions for all services.",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "resources": {
                                "description": "A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "ingressPolicies": {
                    "description": "List of IngressPolicies to apply to the perimeter. A perimeter may have multiple IngressPolicies, each of which is evaluated separately. Access is granted if any Ingress Policy grants it. Must be empty for a perimeter bridge. Structure is documented below.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "ingressFrom": {
                          "description": "Defines the conditions on the source of a request causing this IngressPolicy to apply. Structure is documented below.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "identities": {
                                "description": "A list of identities that are allowed access through this ingress policy. Should be in the format of email address. The email address should represent individual user or service account only.",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              },
                              "identityType": {
                                "description": "Specifies the type of identities that are allowed access from outside the perimeter. If left unspecified, then members of identities field will be allowed access. Possible values are: IDENTITY_TYPE_UNSPECIFIED, ANY_IDENTITY, ANY_USER_ACCOUNT, ANY_SERVICE_ACCOUNT.",
                                "type": "string"
                              },
                              "sources": {
                                "description": "Sources that this IngressPolicy authorizes access from. Structure is documented below.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "resource": {
                                      "description": "A Google Cloud resource that is allowed to ingress the perimeter. Requests from these resources will be allowed to access perimeter data. Currently only projects are allowed. Format projects/{project_number} The project may be in any Google Cloud organization, not just the organization that the perimeter is defined in. * is not allowed, the case of allowing all Google Cloud resources only is not supported.",
                                      "type": "string"
                                    }
                                  }
                                }
                              }
                            }
                          }
                        },
                        "ingressTo": {
                          "description": "Defines the conditions on the ApiOperation and request destination that cause this IngressPolicy to apply. Structure is documented below.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "operations": {
                                "description": "A list of ApiOperations the sources specified in corresponding IngressFrom are allowed to perform in this ServicePerimeter. Structure is documented below.",
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "methodSelectors": {
                                      "description": "API methods or permissions to allow. Method or permission must belong to the service specified by serviceName field. A single MethodSelector entry with * specified for the method field will allow all methods AND permissions for the service specified in serviceName. Structure is documented below.",
                                      "type": "array",
                                      "items": {
                                        "type": "object",
                                        "properties": {
                                          "method": {
                                            "description": "Value for method should be a valid method name for the corresponding serviceName in ApiOperation. If * used as value for method, then ALL methods and permissions are allowed.",
                                            "type": "string"
                                          },
                                          "permission": {
                                            "description": "Value for permission should be a valid Cloud IAM permission for the corresponding serviceName in ApiOperation.",
                                            "type": "string"
                                          }
                                        }
                                      }
                                    },
                                    "serviceName": {
                                      "description": "The name of the API whose methods or permissions the IngressPolicy or EgressPolicy want to allow. A single ApiOperation with serviceName field set to * will allow all methods AND permissions for all services.",
                                      "type": "string"
                                    }
                                  }
                                }
                              },
                              "resources": {
                                "description": "A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "resources": {
                    "description": "A list of GCP resources that are inside of the service perimeter. Currently only projects are allowed. Format: projects/{project_number}",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "restrictedServices": {
                    "description": "GCP services that are subject to the Service Perimeter restrictions. Must contain a list of services. For example, if storage.googleapis.com is specified, access to the storage buckets inside the perimeter must meet the perimeter's access restrictions.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "vpcAccessibleServices": {
                    "description": "Specifies how APIs are allowed to communicate within the Service Perimeter. Structure is documented below.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "allowedServices": {
                          "description": "The list of APIs usable within the Service Perimeter. Must be empty unless enableRestriction is True.",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "enableRestriction": {
                          "description": "Whether to restrict API calls within the Service Perimeter to the list of APIs specified in 'allowedServices'.",
                          "type": "boolean"
                        }
                      }
                    }
                  }
                }
              }
            },
            "title": {
              "description": "Human readable title. Must be unique within the Policy.",
              "type": "string"
            },
            "useExplicitDryRunSpec": {
              "description": "Use explicit dry run spec flag. Ordinarily, a dry-run spec implicitly exists for all Service Perimeters, and that spec is identical to the status for those Service Perimeters. When this flag is set, it inhibits the generation of the implicit spec, thereby allowing the user to explicitly provide a configuration (\"spec\") to use in a dry-run version of the Service Perimeter. This allows the user to test changes to the enforced config (\"status\") without actually enforcing them. This testing is done through analyzing the differences between currently enforced and suggested restrictions. useExplicitDryRunSpec must bet set to True if any of the fields in the spec are set to non-default values.",
              "type": "boolean"
            }
          }
        },
        "managementPolicies": {
          "description": "THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md",
          "type": "array",
          "default": [
            "*"
          ],
          "items": {
            "description": "A ManagementAction represents an action that the Crossplane controllers can take on an external resource.",
            "type": "string",
            "enum": [
              "Observe",
              "Create",
              "Update",
              "Delete",
              "LateInitialize",
              "*"
            ]
          }
        },
        "providerConfigRef": {
          "description": "ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.",
          "type": "object",
          "default": {
            "name": "default"
          },
          "required": [
            "name"
          ],
          "properties": {
            "name": {
              "description": "Name of the referenced object.",
              "type": "string"
            },
            "policy": {
              "description": "Policies for referencing.",
              "type": "object",
              "properties": {
                "resolution": {
                  "description": "Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.",
                  "type": "string",
                  "default": "Required",
                  "enum": [
                    "Required",
                    "Optional"
                  ]
                },
                "resolve": {
                  "description": "Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.",
                  "type": "string",
                  "enum": [
                    "Always",
                    "IfNotPresent"
                  ]
                }
              }
            }
          }
        },
        "publishConnectionDetailsTo": {
          "description": "PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.",
          "type": "object",
          "required": [
            "name"
          ],
          "properties": {
            "configRef": {
              "description": "SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.",
              "type": "object",
              "default": {
                "name": "default"
              },
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "description": "Name of the referenced object.",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for referencing.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  }
                }
              }
            },
            "metadata": {
              "description": "Metadata is the metadata for connection secret.",
              "type": "object",
              "properties": {
                "annotations": {
                  "description": "Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as \"metadata.annotations\". - It is up to Secret Store implementation for others store types.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "labels": {
                  "description": "Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as \"metadata.labels\". - It is up to Secret Store implementation for others store types.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "type": {
                  "description": "Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.",
                  "type": "string"
                }
              }
            },
            "name": {
              "description": "Name is the name of the connection secret.",
              "type": "string"
            }
          }
        },
        "writeConnectionSecretToRef": {
          "description": "WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.",
          "type": "object",
          "required": [
            "name",
            "namespace"
          ],
          "properties": {
            "name": {
              "description": "Name of the secret.",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace of the secret.",
              "type": "string"
            }
          }
        }
      },
      "x-kubernetes-validations": [
        {
          "rule": "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) \u0026\u0026 has(self.initProvider.name))",
          "message": "spec.forProvider.name is a required parameter"
        },
        {
          "rule": "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.parent) || (has(self.initProvider) \u0026\u0026 has(self.initProvider.parent))",
          "message": "spec.forProvider.parent is a required parameter"
        },
        {
          "rule": "!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.title) || (has(self.initProvider) \u0026\u0026 has(self.initProvider.title))",
          "message": "spec.forProvider.title is a required parameter"
        }
      ]
    }
  }
}