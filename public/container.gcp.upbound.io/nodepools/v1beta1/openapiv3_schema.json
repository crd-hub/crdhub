{
  "$schema": "http://json-schema.org/schema#",
  "description": "NodePool is the Schema for the NodePools API. Manages a GKE NodePool resource.",
  "type": "object",
  "required": [
    "spec"
  ],
  "properties": {
    "apiVersion": {
      "description": "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
      "type": "string",
      "enum": [
        "container.gcp.upbound.io/v1beta1"
      ]
    },
    "kind": {
      "description": "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
      "type": "string",
      "enum": [
        "NodePool"
      ]
    },
    "metadata": {
      "type": "object",
      "properties": {
        "annotations": {
          "description": "Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "labels": {
          "description": "Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels",
          "type": "object",
          "additionalProperties": {
            "type": "string"
          }
        },
        "name": {
          "description": "Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names",
          "type": "string"
        }
      }
    },
    "spec": {
      "description": "NodePoolSpec defines the desired state of NodePool",
      "type": "object",
      "required": [
        "forProvider"
      ],
      "properties": {
        "deletionPolicy": {
          "description": "DeletionPolicy specifies what will happen to the underlying external when this managed resource is deleted - either \"Delete\" or \"Orphan\" the external resource. This field is planned to be deprecated in favor of the ManagementPolicies field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223",
          "type": "string",
          "default": "Delete",
          "enum": [
            "Orphan",
            "Delete"
          ]
        },
        "forProvider": {
          "type": "object",
          "properties": {
            "autoscaling": {
              "description": "Configuration required by cluster autoscaler to adjust the size of the node pool to the current cluster usage. Structure is documented below.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "locationPolicy": {
                    "description": "Location policy specifies the algorithm used when scaling-up the node pool. Location policy is supported only in 1.24.1+ clusters.",
                    "type": "string"
                  },
                  "maxNodeCount": {
                    "description": "Maximum number of nodes per zone in the NodePool. Must be \u003e= min_node_count. Cannot be used with total limits.",
                    "type": "number"
                  },
                  "minNodeCount": {
                    "description": "Minimum number of nodes per zone in the NodePool. Must be \u003e=0 and \u003c= max_node_count. Cannot be used with total limits.",
                    "type": "number"
                  },
                  "totalMaxNodeCount": {
                    "description": "Total maximum number of nodes in the NodePool. Must be \u003e= total_min_node_count. Cannot be used with per zone limits. Total size limits are supported only in 1.24.1+ clusters.",
                    "type": "number"
                  },
                  "totalMinNodeCount": {
                    "description": "Total minimum number of nodes in the NodePool. Must be \u003e=0 and \u003c= total_max_node_count. Cannot be used with per zone limits. Total size limits are supported only in 1.24.1+ clusters.",
                    "type": "number"
                  }
                }
              }
            },
            "cluster": {
              "description": "The cluster to create the node pool for. Cluster must be present in location provided for clusters. May be specified in the format projects/{{project}}/locations/{{location}}/clusters/{{cluster}} or as just the name of the cluster.",
              "type": "string"
            },
            "clusterRef": {
              "description": "Reference to a Cluster to populate cluster.",
              "type": "object",
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "description": "Name of the referenced object.",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for referencing.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  }
                }
              }
            },
            "clusterSelector": {
              "description": "Selector for a Cluster to populate cluster.",
              "type": "object",
              "properties": {
                "matchControllerRef": {
                  "description": "MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.",
                  "type": "boolean"
                },
                "matchLabels": {
                  "description": "MatchLabels ensures an object with matching labels is selected.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "policy": {
                  "description": "Policies for selection.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  }
                }
              }
            },
            "initialNodeCount": {
              "description": "The initial number of nodes for the pool. In regional or multi-zonal clusters, this is the number of nodes per zone. Changing this will force recreation of the resource.  If you don't need this value, don't set it.  If you do need it, you can use a lifecycle block to ignore subsequent changes to this field.",
              "type": "number"
            },
            "location": {
              "description": "The location (region or zone) of the cluster.",
              "type": "string"
            },
            "management": {
              "description": "Node management configuration, wherein auto-repair and auto-upgrade is configured. Structure is documented below.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "autoRepair": {
                    "description": "Whether the nodes will be automatically repaired.",
                    "type": "boolean"
                  },
                  "autoUpgrade": {
                    "description": "Whether the nodes will be automatically upgraded.",
                    "type": "boolean"
                  }
                }
              }
            },
            "maxPodsPerNode": {
              "description": "The maximum number of pods per node in this node pool. Note that this does not work on node pools which are \"route-based\" - that is, node pools belonging to clusters that do not have IP Aliasing enabled. See the official documentation for more information.",
              "type": "number"
            },
            "networkConfig": {
              "description": "The network configuration of the pool. Such as configuration for Adding Pod IP address ranges) to the node pool. Or enabling private nodes. Structure is documented below",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "createPodRange": {
                    "description": "Whether to create a new range for pod IPs in this node pool. Defaults are provided for pod_range and pod_ipv4_cidr_block if they are not specified.",
                    "type": "boolean"
                  },
                  "enablePrivateNodes": {
                    "description": "Whether nodes have internal IP addresses only.",
                    "type": "boolean"
                  },
                  "podCidrOverprovisionConfig": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "disabled": {
                          "type": "boolean"
                        }
                      }
                    }
                  },
                  "podIpv4CidrBlock": {
                    "description": "The IP address range for pod IPs in this node pool. Only applicable if createPodRange is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) to pick a specific range to use.",
                    "type": "string"
                  },
                  "podRange": {
                    "description": "The ID of the secondary range for pod IPs. If create_pod_range is true, this ID is used for the new range. If create_pod_range is false, uses an existing secondary range with this ID.",
                    "type": "string"
                  }
                }
              }
            },
            "nodeConfig": {
              "description": "Parameters used in creating the node pool. See google_container_cluster for schema.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "advancedMachineFeatures": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "threadsPerCore": {
                          "type": "number"
                        }
                      }
                    }
                  },
                  "bootDiskKmsKey": {
                    "type": "string"
                  },
                  "diskSizeGb": {
                    "type": "number"
                  },
                  "diskType": {
                    "type": "string"
                  },
                  "ephemeralStorageLocalSsdConfig": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "localSsdCount": {
                          "type": "number"
                        }
                      }
                    }
                  },
                  "gcfsConfig": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "enabled": {
                          "type": "boolean"
                        }
                      }
                    }
                  },
                  "guestAccelerator": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "count": {
                          "type": "number"
                        },
                        "gpuDriverInstallationConfig": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "gpuDriverVersion": {
                                "description": "The Kubernetes version for the nodes in this pool. Note that if this field and auto_upgrade are both specified, they will fight each other for what the node version should be, so setting both is highly discouraged.",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "gpuPartitionSize": {
                          "type": "string"
                        },
                        "gpuSharingConfig": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "gpuSharingStrategy": {
                                "type": "string"
                              },
                              "maxSharedClientsPerGpu": {
                                "type": "number"
                              }
                            }
                          }
                        },
                        "type": {
                          "description": "The type of the policy. Supports a single value: COMPACT. Specifying COMPACT placement policy type places node pool's nodes in a closer physical proximity in order to reduce network latency between nodes.",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "gvnic": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "enabled": {
                          "type": "boolean"
                        }
                      }
                    }
                  },
                  "hostMaintenancePolicy": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "maintenanceInterval": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "imageType": {
                    "type": "string"
                  },
                  "kubeletConfig": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "cpuCfsQuota": {
                          "type": "boolean"
                        },
                        "cpuCfsQuotaPeriod": {
                          "type": "string"
                        },
                        "cpuManagerPolicy": {
                          "type": "string"
                        },
                        "podPidsLimit": {
                          "type": "number"
                        }
                      }
                    }
                  },
                  "labels": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "linuxNodeConfig": {
                    "description": "Parameters used in creating the node pool. See google_container_cluster for schema.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "sysctls": {
                          "type": "object",
                          "additionalProperties": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "localNvmeSsdBlockConfig": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "localSsdCount": {
                          "type": "number"
                        }
                      }
                    }
                  },
                  "localSsdCount": {
                    "type": "number"
                  },
                  "loggingVariant": {
                    "type": "string"
                  },
                  "machineType": {
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "minCpuPlatform": {
                    "type": "string"
                  },
                  "nodeGroup": {
                    "type": "string"
                  },
                  "oauthScopes": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "preemptible": {
                    "type": "boolean"
                  },
                  "reservationAffinity": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "consumeReservationType": {
                          "type": "string"
                        },
                        "key": {
                          "type": "string"
                        },
                        "values": {
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "resourceLabels": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "serviceAccount": {
                    "type": "string"
                  },
                  "serviceAccountRef": {
                    "description": "Reference to a ServiceAccount in cloudplatform to populate serviceAccount.",
                    "type": "object",
                    "required": [
                      "name"
                    ],
                    "properties": {
                      "name": {
                        "description": "Name of the referenced object.",
                        "type": "string"
                      },
                      "policy": {
                        "description": "Policies for referencing.",
                        "type": "object",
                        "properties": {
                          "resolution": {
                            "description": "Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.",
                            "type": "string",
                            "default": "Required",
                            "enum": [
                              "Required",
                              "Optional"
                            ]
                          },
                          "resolve": {
                            "description": "Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.",
                            "type": "string",
                            "enum": [
                              "Always",
                              "IfNotPresent"
                            ]
                          }
                        }
                      }
                    }
                  },
                  "serviceAccountSelector": {
                    "description": "Selector for a ServiceAccount in cloudplatform to populate serviceAccount.",
                    "type": "object",
                    "properties": {
                      "matchControllerRef": {
                        "description": "MatchControllerRef ensures an object with the same controller reference as the selecting object is selected.",
                        "type": "boolean"
                      },
                      "matchLabels": {
                        "description": "MatchLabels ensures an object with matching labels is selected.",
                        "type": "object",
                        "additionalProperties": {
                          "type": "string"
                        }
                      },
                      "policy": {
                        "description": "Policies for selection.",
                        "type": "object",
                        "properties": {
                          "resolution": {
                            "description": "Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.",
                            "type": "string",
                            "default": "Required",
                            "enum": [
                              "Required",
                              "Optional"
                            ]
                          },
                          "resolve": {
                            "description": "Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.",
                            "type": "string",
                            "enum": [
                              "Always",
                              "IfNotPresent"
                            ]
                          }
                        }
                      }
                    }
                  },
                  "shieldedInstanceConfig": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "enableIntegrityMonitoring": {
                          "type": "boolean"
                        },
                        "enableSecureBoot": {
                          "type": "boolean"
                        }
                      }
                    }
                  },
                  "soleTenantConfig": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "nodeAffinity": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "key": {
                                "type": "string"
                              },
                              "operator": {
                                "type": "string"
                              },
                              "values": {
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "spot": {
                    "type": "boolean"
                  },
                  "tags": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "taint": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "effect": {
                          "type": "string"
                        },
                        "key": {
                          "type": "string"
                        },
                        "value": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "workloadMetadataConfig": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "mode": {
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "nodeCount": {
              "description": "The number of nodes per instance group. This field can be used to update the number of nodes per instance group but should not be used alongside autoscaling.",
              "type": "number"
            },
            "nodeLocations": {
              "description": "The list of zones in which the node pool's nodes should be located. Nodes must be in the region of their regional cluster or in the same region as their cluster's zone for zonal clusters. If unspecified, the cluster-level node_locations will be used.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "placementPolicy": {
              "description": "Specifies a custom placement policy for the nodes.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "policyName": {
                    "description": "If set, refers to the name of a custom resource policy supplied by the user. The resource policy must be in the same project and region as the node pool. If not found, InvalidArgument error is returned.",
                    "type": "string"
                  },
                  "type": {
                    "description": "The type of the policy. Supports a single value: COMPACT. Specifying COMPACT placement policy type places node pool's nodes in a closer physical proximity in order to reduce network latency between nodes.",
                    "type": "string"
                  }
                }
              }
            },
            "project": {
              "description": "The ID of the project in which to create the node pool. If blank, the provider-configured project will be used.",
              "type": "string"
            },
            "upgradeSettings": {
              "description": "Specify node upgrade settings to change how GKE upgrades nodes. The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "blueGreenSettings": {
                    "description": "The settings to adjust blue green upgrades. Structure is documented below",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "nodePoolSoakDuration": {
                          "description": "Time needed after draining the entire blue pool. After this period, the blue pool will be cleaned up.",
                          "type": "string"
                        },
                        "standardRolloutPolicy": {
                          "description": "Specifies the standard policy settings for blue-green upgrades.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "batchNodeCount": {
                                "description": "Number of blue nodes to drain in a batch.",
                                "type": "number"
                              },
                              "batchPercentage": {
                                "description": "Percentage of the blue pool nodes to drain in a batch.",
                                "type": "number"
                              },
                              "batchSoakDuration": {
                                "description": "(Optionial) Soak time after each batch gets drained.",
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "maxSurge": {
                    "description": "The number of additional nodes that can be added to the node pool during an upgrade. Increasing max_surge raises the number of nodes that can be upgraded simultaneously. Can be set to 0 or greater.",
                    "type": "number"
                  },
                  "maxUnavailable": {
                    "description": "The number of nodes that can be simultaneously unavailable during an upgrade. Increasing max_unavailable raises the number of nodes that can be upgraded in parallel. Can be set to 0 or greater.",
                    "type": "number"
                  },
                  "strategy": {
                    "description": "(Default SURGE) The upgrade stragey to be used for upgrading the nodes.",
                    "type": "string"
                  }
                }
              }
            },
            "version": {
              "description": "The Kubernetes version for the nodes in this pool. Note that if this field and auto_upgrade are both specified, they will fight each other for what the node version should be, so setting both is highly discouraged.",
              "type": "string"
            }
          }
        },
        "initProvider": {
          "description": "THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. InitProvider holds the same fields as ForProvider, with the exception of Identifier and other resource reference fields. The fields that are in InitProvider are merged into ForProvider when the resource is created. The same fields are also added to the terraform ignore_changes hook, to avoid updating them after creation. This is useful for fields that are required on creation, but we do not desire to update them after creation, for example because of an external controller is managing them, like an autoscaler.",
          "type": "object",
          "properties": {
            "autoscaling": {
              "description": "Configuration required by cluster autoscaler to adjust the size of the node pool to the current cluster usage. Structure is documented below.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "locationPolicy": {
                    "description": "Location policy specifies the algorithm used when scaling-up the node pool. Location policy is supported only in 1.24.1+ clusters.",
                    "type": "string"
                  },
                  "maxNodeCount": {
                    "description": "Maximum number of nodes per zone in the NodePool. Must be \u003e= min_node_count. Cannot be used with total limits.",
                    "type": "number"
                  },
                  "minNodeCount": {
                    "description": "Minimum number of nodes per zone in the NodePool. Must be \u003e=0 and \u003c= max_node_count. Cannot be used with total limits.",
                    "type": "number"
                  },
                  "totalMaxNodeCount": {
                    "description": "Total maximum number of nodes in the NodePool. Must be \u003e= total_min_node_count. Cannot be used with per zone limits. Total size limits are supported only in 1.24.1+ clusters.",
                    "type": "number"
                  },
                  "totalMinNodeCount": {
                    "description": "Total minimum number of nodes in the NodePool. Must be \u003e=0 and \u003c= total_max_node_count. Cannot be used with per zone limits. Total size limits are supported only in 1.24.1+ clusters.",
                    "type": "number"
                  }
                }
              }
            },
            "initialNodeCount": {
              "description": "The initial number of nodes for the pool. In regional or multi-zonal clusters, this is the number of nodes per zone. Changing this will force recreation of the resource.  If you don't need this value, don't set it.  If you do need it, you can use a lifecycle block to ignore subsequent changes to this field.",
              "type": "number"
            },
            "management": {
              "description": "Node management configuration, wherein auto-repair and auto-upgrade is configured. Structure is documented below.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "autoRepair": {
                    "description": "Whether the nodes will be automatically repaired.",
                    "type": "boolean"
                  },
                  "autoUpgrade": {
                    "description": "Whether the nodes will be automatically upgraded.",
                    "type": "boolean"
                  }
                }
              }
            },
            "maxPodsPerNode": {
              "description": "The maximum number of pods per node in this node pool. Note that this does not work on node pools which are \"route-based\" - that is, node pools belonging to clusters that do not have IP Aliasing enabled. See the official documentation for more information.",
              "type": "number"
            },
            "networkConfig": {
              "description": "The network configuration of the pool. Such as configuration for Adding Pod IP address ranges) to the node pool. Or enabling private nodes. Structure is documented below",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "createPodRange": {
                    "description": "Whether to create a new range for pod IPs in this node pool. Defaults are provided for pod_range and pod_ipv4_cidr_block if they are not specified.",
                    "type": "boolean"
                  },
                  "enablePrivateNodes": {
                    "description": "Whether nodes have internal IP addresses only.",
                    "type": "boolean"
                  },
                  "podCidrOverprovisionConfig": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "disabled": {
                          "type": "boolean"
                        }
                      }
                    }
                  },
                  "podIpv4CidrBlock": {
                    "description": "The IP address range for pod IPs in this node pool. Only applicable if createPodRange is true. Set to blank to have a range chosen with the default size. Set to /netmask (e.g. /14) to have a range chosen with a specific netmask. Set to a CIDR notation (e.g. 10.96.0.0/14) to pick a specific range to use.",
                    "type": "string"
                  },
                  "podRange": {
                    "description": "The ID of the secondary range for pod IPs. If create_pod_range is true, this ID is used for the new range. If create_pod_range is false, uses an existing secondary range with this ID.",
                    "type": "string"
                  }
                }
              }
            },
            "nodeConfig": {
              "description": "Parameters used in creating the node pool. See google_container_cluster for schema.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "advancedMachineFeatures": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "threadsPerCore": {
                          "type": "number"
                        }
                      }
                    }
                  },
                  "bootDiskKmsKey": {
                    "type": "string"
                  },
                  "diskSizeGb": {
                    "type": "number"
                  },
                  "diskType": {
                    "type": "string"
                  },
                  "ephemeralStorageLocalSsdConfig": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "localSsdCount": {
                          "type": "number"
                        }
                      }
                    }
                  },
                  "gcfsConfig": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "enabled": {
                          "type": "boolean"
                        }
                      }
                    }
                  },
                  "guestAccelerator": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "count": {
                          "type": "number"
                        },
                        "gpuDriverInstallationConfig": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "gpuDriverVersion": {
                                "description": "The Kubernetes version for the nodes in this pool. Note that if this field and auto_upgrade are both specified, they will fight each other for what the node version should be, so setting both is highly discouraged.",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "gpuPartitionSize": {
                          "type": "string"
                        },
                        "gpuSharingConfig": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "gpuSharingStrategy": {
                                "type": "string"
                              },
                              "maxSharedClientsPerGpu": {
                                "type": "number"
                              }
                            }
                          }
                        },
                        "type": {
                          "description": "The type of the policy. Supports a single value: COMPACT. Specifying COMPACT placement policy type places node pool's nodes in a closer physical proximity in order to reduce network latency between nodes.",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "gvnic": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "enabled": {
                          "type": "boolean"
                        }
                      }
                    }
                  },
                  "hostMaintenancePolicy": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "maintenanceInterval": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "imageType": {
                    "type": "string"
                  },
                  "kubeletConfig": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "cpuCfsQuota": {
                          "type": "boolean"
                        },
                        "cpuCfsQuotaPeriod": {
                          "type": "string"
                        },
                        "cpuManagerPolicy": {
                          "type": "string"
                        },
                        "podPidsLimit": {
                          "type": "number"
                        }
                      }
                    }
                  },
                  "labels": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "linuxNodeConfig": {
                    "description": "Parameters used in creating the node pool. See google_container_cluster for schema.",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "sysctls": {
                          "type": "object",
                          "additionalProperties": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "localNvmeSsdBlockConfig": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "localSsdCount": {
                          "type": "number"
                        }
                      }
                    }
                  },
                  "localSsdCount": {
                    "type": "number"
                  },
                  "loggingVariant": {
                    "type": "string"
                  },
                  "machineType": {
                    "type": "string"
                  },
                  "metadata": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "minCpuPlatform": {
                    "type": "string"
                  },
                  "nodeGroup": {
                    "type": "string"
                  },
                  "oauthScopes": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "preemptible": {
                    "type": "boolean"
                  },
                  "reservationAffinity": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "consumeReservationType": {
                          "type": "string"
                        },
                        "key": {
                          "type": "string"
                        },
                        "values": {
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      }
                    }
                  },
                  "resourceLabels": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  },
                  "shieldedInstanceConfig": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "enableIntegrityMonitoring": {
                          "type": "boolean"
                        },
                        "enableSecureBoot": {
                          "type": "boolean"
                        }
                      }
                    }
                  },
                  "soleTenantConfig": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "nodeAffinity": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "key": {
                                "type": "string"
                              },
                              "operator": {
                                "type": "string"
                              },
                              "values": {
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "spot": {
                    "type": "boolean"
                  },
                  "tags": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "taint": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "effect": {
                          "type": "string"
                        },
                        "key": {
                          "type": "string"
                        },
                        "value": {
                          "type": "string"
                        }
                      }
                    }
                  },
                  "workloadMetadataConfig": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "mode": {
                          "type": "string"
                        }
                      }
                    }
                  }
                }
              }
            },
            "nodeCount": {
              "description": "The number of nodes per instance group. This field can be used to update the number of nodes per instance group but should not be used alongside autoscaling.",
              "type": "number"
            },
            "nodeLocations": {
              "description": "The list of zones in which the node pool's nodes should be located. Nodes must be in the region of their regional cluster or in the same region as their cluster's zone for zonal clusters. If unspecified, the cluster-level node_locations will be used.",
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "placementPolicy": {
              "description": "Specifies a custom placement policy for the nodes.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "policyName": {
                    "description": "If set, refers to the name of a custom resource policy supplied by the user. The resource policy must be in the same project and region as the node pool. If not found, InvalidArgument error is returned.",
                    "type": "string"
                  },
                  "type": {
                    "description": "The type of the policy. Supports a single value: COMPACT. Specifying COMPACT placement policy type places node pool's nodes in a closer physical proximity in order to reduce network latency between nodes.",
                    "type": "string"
                  }
                }
              }
            },
            "project": {
              "description": "The ID of the project in which to create the node pool. If blank, the provider-configured project will be used.",
              "type": "string"
            },
            "upgradeSettings": {
              "description": "Specify node upgrade settings to change how GKE upgrades nodes. The maximum number of nodes upgraded simultaneously is limited to 20. Structure is documented below.",
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "blueGreenSettings": {
                    "description": "The settings to adjust blue green upgrades. Structure is documented below",
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "nodePoolSoakDuration": {
                          "description": "Time needed after draining the entire blue pool. After this period, the blue pool will be cleaned up.",
                          "type": "string"
                        },
                        "standardRolloutPolicy": {
                          "description": "Specifies the standard policy settings for blue-green upgrades.",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "batchNodeCount": {
                                "description": "Number of blue nodes to drain in a batch.",
                                "type": "number"
                              },
                              "batchPercentage": {
                                "description": "Percentage of the blue pool nodes to drain in a batch.",
                                "type": "number"
                              },
                              "batchSoakDuration": {
                                "description": "(Optionial) Soak time after each batch gets drained.",
                                "type": "string"
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  "maxSurge": {
                    "description": "The number of additional nodes that can be added to the node pool during an upgrade. Increasing max_surge raises the number of nodes that can be upgraded simultaneously. Can be set to 0 or greater.",
                    "type": "number"
                  },
                  "maxUnavailable": {
                    "description": "The number of nodes that can be simultaneously unavailable during an upgrade. Increasing max_unavailable raises the number of nodes that can be upgraded in parallel. Can be set to 0 or greater.",
                    "type": "number"
                  },
                  "strategy": {
                    "description": "(Default SURGE) The upgrade stragey to be used for upgrading the nodes.",
                    "type": "string"
                  }
                }
              }
            },
            "version": {
              "description": "The Kubernetes version for the nodes in this pool. Note that if this field and auto_upgrade are both specified, they will fight each other for what the node version should be, so setting both is highly discouraged.",
              "type": "string"
            }
          }
        },
        "managementPolicies": {
          "description": "THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored unless the relevant Crossplane feature flag is enabled, and may be changed or removed without notice. ManagementPolicies specify the array of actions Crossplane is allowed to take on the managed and external resources. This field is planned to replace the DeletionPolicy field in a future release. Currently, both could be set independently and non-default values would be honored if the feature flag is enabled. If both are custom, the DeletionPolicy field will be ignored. See the design doc for more information: https://github.com/crossplane/crossplane/blob/499895a25d1a1a0ba1604944ef98ac7a1a71f197/design/design-doc-observe-only-resources.md?plain=1#L223 and this one: https://github.com/crossplane/crossplane/blob/444267e84783136daa93568b364a5f01228cacbe/design/one-pager-ignore-changes.md",
          "type": "array",
          "default": [
            "*"
          ],
          "items": {
            "description": "A ManagementAction represents an action that the Crossplane controllers can take on an external resource.",
            "type": "string",
            "enum": [
              "Observe",
              "Create",
              "Update",
              "Delete",
              "LateInitialize",
              "*"
            ]
          }
        },
        "providerConfigRef": {
          "description": "ProviderConfigReference specifies how the provider that will be used to create, observe, update, and delete this managed resource should be configured.",
          "type": "object",
          "default": {
            "name": "default"
          },
          "required": [
            "name"
          ],
          "properties": {
            "name": {
              "description": "Name of the referenced object.",
              "type": "string"
            },
            "policy": {
              "description": "Policies for referencing.",
              "type": "object",
              "properties": {
                "resolution": {
                  "description": "Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.",
                  "type": "string",
                  "default": "Required",
                  "enum": [
                    "Required",
                    "Optional"
                  ]
                },
                "resolve": {
                  "description": "Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.",
                  "type": "string",
                  "enum": [
                    "Always",
                    "IfNotPresent"
                  ]
                }
              }
            }
          }
        },
        "publishConnectionDetailsTo": {
          "description": "PublishConnectionDetailsTo specifies the connection secret config which contains a name, metadata and a reference to secret store config to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource.",
          "type": "object",
          "required": [
            "name"
          ],
          "properties": {
            "configRef": {
              "description": "SecretStoreConfigRef specifies which secret store config should be used for this ConnectionSecret.",
              "type": "object",
              "default": {
                "name": "default"
              },
              "required": [
                "name"
              ],
              "properties": {
                "name": {
                  "description": "Name of the referenced object.",
                  "type": "string"
                },
                "policy": {
                  "description": "Policies for referencing.",
                  "type": "object",
                  "properties": {
                    "resolution": {
                      "description": "Resolution specifies whether resolution of this reference is required. The default is 'Required', which means the reconcile will fail if the reference cannot be resolved. 'Optional' means this reference will be a no-op if it cannot be resolved.",
                      "type": "string",
                      "default": "Required",
                      "enum": [
                        "Required",
                        "Optional"
                      ]
                    },
                    "resolve": {
                      "description": "Resolve specifies when this reference should be resolved. The default is 'IfNotPresent', which will attempt to resolve the reference only when the corresponding field is not present. Use 'Always' to resolve the reference on every reconcile.",
                      "type": "string",
                      "enum": [
                        "Always",
                        "IfNotPresent"
                      ]
                    }
                  }
                }
              }
            },
            "metadata": {
              "description": "Metadata is the metadata for connection secret.",
              "type": "object",
              "properties": {
                "annotations": {
                  "description": "Annotations are the annotations to be added to connection secret. - For Kubernetes secrets, this will be used as \"metadata.annotations\". - It is up to Secret Store implementation for others store types.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "labels": {
                  "description": "Labels are the labels/tags to be added to connection secret. - For Kubernetes secrets, this will be used as \"metadata.labels\". - It is up to Secret Store implementation for others store types.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                },
                "type": {
                  "description": "Type is the SecretType for the connection secret. - Only valid for Kubernetes Secret Stores.",
                  "type": "string"
                }
              }
            },
            "name": {
              "description": "Name is the name of the connection secret.",
              "type": "string"
            }
          }
        },
        "writeConnectionSecretToRef": {
          "description": "WriteConnectionSecretToReference specifies the namespace and name of a Secret to which any connection details for this managed resource should be written. Connection details frequently include the endpoint, username, and password required to connect to the managed resource. This field is planned to be replaced in a future release in favor of PublishConnectionDetailsTo. Currently, both could be set independently and connection details would be published to both without affecting each other.",
          "type": "object",
          "required": [
            "name",
            "namespace"
          ],
          "properties": {
            "name": {
              "description": "Name of the secret.",
              "type": "string"
            },
            "namespace": {
              "description": "Namespace of the secret.",
              "type": "string"
            }
          }
        }
      }
    }
  }
}